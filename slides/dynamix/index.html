<!doctype html>
<html lang="bg">

<head>
    <meta charset="utf-8">

    <title>DynaMix: A new take on polymorphism in C++</title>

    <meta name="description" content="Slides for a talk about DynaMix">
    <meta name="author" content="Borislav Stanimirov">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="/third_party/reveal/css/reveal.min.css">
    <link rel="stylesheet" href="/third_party/reveal/css/theme/default.css" id="theme">

    <!-- The default heading font doesn't work well with Cyrillic. Change it here -->
    <link rel="stylesheet" href="custom.css">

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="/third_party/highlight/css/default.css">

    <!-- If the query includes 'print-pdf', use the PDF print sheet -->
    <script>
    document.write( '<link rel="stylesheet" href="/third_party/reveal/css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
    </script>

    <!--[if lt IE 9]>
    <script src="/third_party/reveal/lib/js/html5shiv.js"></script>
    <![endif]-->
</head>

<body>

    <div class="reveal">
        <div class="slides">

            <section>
                <h1>DynaMix</h1>
                <h3>A New Take on Polymorphism in C++</h3>
                <p>
                    by <a href="http://ibob.github.io">Borislav Stanimirov</a>
                </p>
            </section>

            <section class="slide">
                <h3>About</h3>
                <ul>
                    <li>Hi. I'm Borislav.</li>
                    <li><span class="fancy">DynaMix</span> is a C++ library</li>
                    <ul>
                        <li><a href="https://github.com/iboB/dynamix">github.com/iboB/dynamix</a></li>
                    </ul>
                    <li>History</li>
                    <ul>
                        <li>2007: Interface. Zahary Karadjov</li>
                        <li>2013: Rebirth as <span class="fancy">Boost.Mixin</span>. Me</li>
                        <li>2016: Bye, Boost. Hello, <span class="fancy">DynaMix</span></li>
                    </ul>
                    <li>Spread <em>(to my knowledge)</em></li>
                    <ul>
                        <li>One PC MMORPG</li>
                        <li>One released mobile game</li>
                        <li>Two mobile games in development</li>
                    </ul>
                </ul>
            </section>

            <section class="slide">
                <h3>About 2.0</h3>
                <ul>
                    <li>What will be in this talk?</li>
                    <ul>
                        <li>Introducing the <span class="fancy">DynaMix</span> library</li>
                        <li>We will focus on the <span class="fancy">"what"</span> and the <span class="fancy">"why"</span></li>
                        <li>We will hardly even mention the "how"</li>
                    </ul>
                    <li>So, what does this library do?</li>
                    <ul>
                        <li>A means to create a project's <span class="fancy">architecture</span> rather than achieve its purpose</li>
                        <li>Management of <span class="fancy">complex objects</span> in potentially <span class="fancy">multiple subsystems</span></li>
                        <li>Enforces OOP practices like <span class="fancy">composition over inheritance</span>, <span class="fancy">loose coupling</span>, and <span class="fancy">separation of interface and implementation</span></li>
                    </ul>
                </ul>
            </section>

            <section class="slide">
                <h3>The Gist</h3>
                <ul>
                    <li>Building blocks</li>
                    <ul>
                        <li><code class="inline">dynamix::object</code> - just an empty object</li>
                        <li><span class="fancy">Messages</span> - function-like pieces of interface, that an object might implement</li>
                        <li><span class="fancy">Mixins</span> - classes that you've written which actually implement messages</li>
                    </ul>
                    <li>Usage</li>
                    <ul>
                        <li><span class="fancy">Mutation</span> - the process of adding and removing mixins from objects</li>
                        <li><span class="fancy">Calling messages</span> - like calling methods, this is where the actual business logic lies</li>
                    </ul>
                    <li class="evil">I know what a mixin is and it's not this</li>
                    <ul>
                        <li>DynaMix = <span class="fancy">dynamic mixins</span></li>
                    </ul>
                </ul>
            </section>

            <section>
                <h2>Why don't we see some code?</h2>
            </section>

            <section>
<pre><code class="cpp hljs">
class wood_frame
{
public:
    strength get_strength() const {
        return strength(83);
    }
    // other wood-frame-y stuff
};

class titanium_frame
{
public:
    strength get_strength() const {
        return strength(9001);
    }
    // other titanium-frame-y stuff
};

</code></pre>
            </section>

            <section>
<pre><code class="cpp hljs">
class has_drawers
{
public:
    void open(int element) {
        _drawers[element].roll_out();
    }
    // ...
};

class has_doors
{
public:
    void open(int element) {
        _doors[element].open();
    }
    // ...
};

</code></pre>
            </section>

            <section>
<pre><code class="cpp hljs">
// ...after some library-specific code in which we "tell"
// it what mixins and messages there are out there

dynamix::object o;
mutate(o) // composition
    .add&lt;wood_frame&gt;()
    .add&lt;has_doors&gt;();

// message calls
::get_strength(o); // -> strength 83
::open(o, 1); // -> right door opens

mutate(o) // mutation
    .remove&lt;wood_frame&gt;()
    .add&lt;titanium_frame&gt;();

::get_strength(o); // -> strength 9001

</code></pre>
            </section>

            <section>
                <h2>An Actual Basic Example</h2>
                <img src="basic_example.png" />
            </section>

            <section>
                <h2>But why?</h2>
            </section>

            <section class="slide">
                <h3>OOP and Polymorphism</h3>
                <ul>
                    <li>OOP has come to imply dynamic polymorphism</li>
                    <ul>
                        <li>Dynamic polymorphism is when the compiler can see a function call but <span class="fancy">can't know</span> which actual piece of code will be executed next</li>
                        <li>It's in the category of things which are <span class="fancy">slower</span> and <span class="fancy">can't have good compilation errors</span></li>
                        <li>Totally anti modern C++</li>
                    </ul>
                    <li>OOP has been critized a lot</li>
                    <li>C++ is, among other things, an <span class="fancy">OOP language</span></li>
                    <li>Out of the box in an OOP context C++ only gives us <span class="fancy">virtual functions</span> for polymorphism</li>
                </ul>
            </section>

            <section class="slide">
                <h3>An Example Problem</h3>
                <br/>
                <ul>
                    <li>Suppose we want to have an object which is:</li>
                    <ul>
                        <li>A flying creature</li>
                        <li>A two-legged creature</li>
                        <li>Is controlled by a hostile AI</li>
                        <li>Has an associated animated model</li>
                        <li>Has DirectX rendering code</li>
                    </ul>
                </ul>
            </section>

            <section>
                <img class="diagram" src="dragon.png" />
            </section>

            <section>
            <p class="evil">That's easy</p>
<pre><code class="cpp hljs">
class dragon
{
public:
    void fly();
    void walk_on_two_legs();
    void ai_take_the_wheel();
    const model& get_model() const;
    void render_with_directx() const;
// ...
}
</code></pre>
            </section>

            <section class="slide">
                <h3>Implied Conditions</h3>
                <br/>
                <ul>
                    <li>We will have other objects in our game</li>
                    <li>Different subsystems of the game care about different aspects of those objects</li>
                    <li>Different parts of the object may rely on others to work</li>
                </ul>
                <br/>
                <br/>
                <p style="text-align:center">What if we also have a horse or a human character?</p>
            </section>

            <section>
                <img class="diagram" src="inheritance.png" />
            </section>

            <section>
            <p class="evil">Still easy</p>
<pre><code class="cpp hljs">
class dragon : public flying_creature,
    public two_legged_creature, public monster_ai,
    public animated_model, public directx_rendering
{};

class horse : public walking_creature,
    public four_legged_creature, public neutral_ai,
    public animated_model, public direcx_rendering
{};

// ... you get the point
</code></pre>
            </section>

            <section>
                <p>That, in a way, is even worse, because <code class="inline">flying_creature</code> has no way of telling <code class="inline">animated_model</code> which animation to play.</p>
            </section>

            <section>
                <p class="evil">OK. This time using <span class="fancy">real</span> mixins</p>
<pre><code class="cpp hljs">
template &lt;typename object_type&gt;
class flying_creature
{
public:
    void move()
    {
        flap_wings();
        static_cast&lt;object_type*&gt;(this)
            ->set_animation("flying");
    }
// ...
};

class dragon : public flying_creature&lt;dragon&gt;,
    public two_legged_creature&lt;dragon&gt;,
    public monster_ai&lt;dragon&gt;,
    public animated_model&lt;dragon&gt;,
    public directx_rendering&lt;dragon&gt;
{};

</code></pre>
            </section>

            <section class="slide">
                <br/>
                <br/>
                <ul>
                    <li><span class="fancy">ALL</span> of my code is in headers</li>
                    <li>How can I have an array of objects?</li>
                </ul>
                <br/>
                <br/>
<pre><code class="cpp hljs" data-trim>
template &lt;typename object_type&gt;
class flying_creature : public virtual game_object
{ /* ... */ };

std::vector&lt;game_object*&gt; objects;
</code></pre>
                <br/>
                <p>This is identical to <code class="inline">vector&lt;void*&gt;</code>.<br/>I have no way of using the objects in this array.</li>
                </ul>
            </section>

            <section>
                <p class="evil">Fine. I'm rolling-up my sleeves</p>
<pre><code class="cpp hljs">
class flying_creature : public virtual game_object
{
public:
    virtual void fly() override
    {
        this->flap_wings();
        this->set_animation("flying");
    }
// ...
};

class dragon : public flying_creature,
    public two_legged_creature, public monster_ai,
    public animated_model, public directx_rendering
{
};

</code></pre>
            </section>

            <section class="slide">
                <br/>
                <p>So, all, <span class="fancy">ALL</span> possible methods will exist as pure virtual in <code class="inline">game_object</code></p>
                <p>Also, walking creature cannot fly. You can never instantiate <code class="inline">dragon</code> since it's abstract.</p>
                <br/>
                <br/>
                <p class="evil">Having separate methods for flying and walking was a bad idea, anyway. There should be a single method: <code class="inline">move</code>. In fact how about this:</p>
            </section>

            <section>
<pre><code class="cpp hljs">
class game_object
{
    virtual void move() = 0; // flying, walking, vehicles
    // enemy/neutral ai, keyboard control
    virtual void decide_action() = 0;
    //...
};

class dragon : public flying_creature,
    public two_legged_creature, public monster_ai,
    public animated_model, public directx_rendering
{
    // there still might be invalid actions for the object
    // list them here
    virtual void use(item*) override {
        throw bad_call();
    }
};

</code></pre>
            </section>

            <section class="slide">
                <p>This will work.</p>
                <p class="evil">Aww, yiss!</p>
                <p>But...</p>
                <br/>
                <ul>
                    <li>It's impractical</li>
                    <li>Every new type of object, needs to be explicity added to the code</li>
                    <li>Combinatorial explosion of types</li>
                    <li><code class="inline">game_object</code> is a coupling focal point</li>
                    <li>As a result no software is written like this (except probably some beginner projects)</li>
                </ul>
            </section>

            <section class="slide">
                <h3>An Example Problem Cont.</h3>
                <br/>
                <ul>
                    <li>Suppose that we also want</li>
                    <ul>
                        <li>To sometimes manually control the dragon</li>
                        <li>To cut the wings off of the dragon and have a plain (well two-legged) lizzard</li>
                        <li>To optionally have add fire-breathing powers to our dragon</li>
                        <li>To be able to choose the rendering API, say to switch to OpenGL</li>
                    </ul>
                </ul>
                <br/>
                <br/>
                <p class="evil">I could add such if-checks to all my methods, but I suppose you won't like this</p>
            </section>

            <section>
            <p class="evil">Object</p>
<pre><code class="cpp hljs">
class game_object
{
    control* m_control;
    physical_data* m_physical_data;
    rendering* m_rendering;
    mobility* m_mobility;
    ...
};
// compose
game_entity dragon;
dragon.set_control(new monster_ai);
dragon.set_physical_data(new animated_model("dragon.x"));
dragon.set_mobility(new flyer);
...
// modify
dragon.set_control(new player_control);

</code></pre>
            </section>

            <section>
            <p class="evil">Component</p>
<pre><code class="cpp hljs">
class component
{
    game_object* self;
};

class monster_ai
    : public control, public component
{
    virtual void decide_action() override
    {
        ...
        self->get_mobility()->move_to(good_guy);
    }
};

</code></pre>
            </section>

            <section class="slide">
                <p>This is, actually, a pretty decent solution.</p>
                <br/>
                <ul>
                    <li>This is the <span class="fancy">interface to component</span> pattern</li>
                    <li>There are <span class="fancy">games</span> and <span class="fancy">CAD systems</span> which use it</li>
                    <li>In fact (although not immediately  obvious), using this as a base, you can recreate almost every feature of DynaMix (in a concrete and <span class="fancy">unreusable</span> way)</li>
                </ul>
                <p>But...</p>
                <ul>
                    <li>Every new type of interface needs to be explicitly added to the <span class="fancy">huge</span> object class</li>
                    <li>More importantly: <span class="fancy">Interface classes are limiting</span></li>
                </ul>
            </section>

            <section class="slide">
                <h3>Pushing The Limits</h3>
<pre><code class="cpp hljs" data-trim>
struct mobility
{
    virtual void move_to(target t) = 0;
    virtual bool can_move_to(target t) const = 0;
};
</code></pre>
                <p>What if we want to override only <code class="inline">can_move_to</code>?</li>
                <br/>
                <br/>
                <p class="evil">OK. I give up. In such cases people just don't use C++. You want to embed a scripting language like Python, or Lua, or JavaScript.</p>
                <br/>
                <p>That's a decent solution too.</li>
            </section>

            <section>
<pre><code class="ruby hljs" data-trim>
module FlyingCreature
  def move_to(target)
      puts can_move_to?(target) ?
        "flying to #{target}"
        : "can't fly to #{target}"
  end
  def can_move_to?(target)
    true # flying creatures don't care
  end
end

module AfraidOfEvens
  def can_move_to?(target)
    return target%2 != 0
  end
end

a = Object.new
a.extend(FlyingCreature)
a.move_to(10)
a.extend(AfraidOfEvens)
a.move_to(10)
</code></pre>
            </section>

            <section class="slide">
                <h3>The Same in C++</h3>
                <br/>
                <ul>
                    <li>Composition over inheritance</li>
                    <li>Late binding</li>
                    <li>"Messages" over "methods"</li>
                    <li>Messages separate from classes</li>
                    <li>...and more</li>
                </ul>
            </section>

            <section>
                <h2>DynaMix Solution</h2>
                <p>Finally</p>
            </section>

            <section>
            <p>DynaMix Dragon</p>
<pre><code class="cpp hljs" data-trim>
object dragon; // just an empty object

mutate(dragon)
    .add&lt;flying_creature&gt;()
    .add&lt;two_legged_creature&gt;()
    .add&lt;monster_ai&gt;()
    .add&lt;animated_model&gt;()
    .add&lt;directx_rendering&gt;();

::set_model(dragon, "dragon.x");
//...
::decide_action(dragon); // attack player

mutate(dragon)
    .remove&lt;monster_ai&gt;()
    .add&lt;player_control&gt;();

::decide_action(dragon); // read keyboard
</code></pre>
            </section>

            <section>
            <p>DynaMix Mixin</p>
            <br/>
<pre><code class="cpp hljs" data-trim>
class monster_ai
{
    void decide_action()
    {
        ...
        ::move_to(dm_this, good_guy);
    }
};
</code></pre>
            <ul>
                <li>Yup. No inheritance. The libary is non-intrusive.</li>
                <li><code class="inline">dm_this</code> is like <code class="inline">self</code>: the object we're a part of</li>
            </ul>
            </section>

            <section class="slide">
                <h3>This Is Impossible!</h3>
                <br/>
                <ul>
                    <li>Yes it is.</li>
                    <li>In a header file we need:</li>
                </ul>
                <pre><code class="cpp hljs" data-trim>DYNAMIX_DECLARE_MIXIN(monster_ai);</code></pre>
                <ul>
                    <li>This is enough to mutate objects</li>
                    <li>Also in a .cpp file we need:</li>
                </ul>
                <pre><code class="cpp hljs" data-trim>DYNAMIX_DEFINE_MIXIN(monster_ai, decide_actions_msg);</code></pre>
                <ul>
                    <li>This is how we "tell" the library which messages will be added to the object's interface, when this mixin is mutated-in</li>
                </ul>
            </section>

            <section class="slide">
                <h3>Messages</h3>
                <br/>
<pre><code class="cpp hljs" data-trim>
DYNAMIX_MESSAGE_0(void, simulate_tick);
DYNAMIX_MESSAGE_1(void, move_to, object*, target);
DYNAMIX_MESSAGE_2(rt, foo, arg1_t, arg1, arg2_t, arg2);
</code></pre>
<pre><code class="cpp hljs" data-trim>
DYNAMIX_DEFINE_MESSAGE(simulate_tick);
DYNAMIX_DEFINE_MESSAGE(move_to);
DYNAMIX_DEFINE_MESSAGE(foo);
</code></pre>
            <ul>
                <br/>
                <p>And that's how we truly separate the interface from the implementation.</p>
            </section>

            <section style="background-color: green;">
                <h2 style="color: pink;">Eye candy time!</h2>
            </section>

            <section class="slide">
                <h3>Recap</h3>
                <ul>
                    <li>Compose and mutate objects from mixins</li>
                    <li>Have uni- and multicast messages</li>
                    <li>Manager message execution with priorities</li>
                    <li>Easily have hot-swappable or even releaseble plugins</li>
                    <li>There was no time for:</li>
                    <ul>
                        <li>Custom allocators</li>
                        <li>Multicast result combinators</li>
                        <li>Implementation details</li>
                    </ul>
                </ul>
            </section>

            <section>
                <h1>End</h1>
                <h2>Questions?</h2>
                <br/>
                <p>Borislav Stanimirov / <a href="http://ibob.github.io">ibob.github.io</a></p>
                <p>
                    <br />
                    <small>
                    Link to these slides: <a href="http://ibob.github.io/slides/dynamix/">http://ibob.github.io/slides/dynamix/</a>
                    </small>
                    <br />
                    <small>
                    Slides license <a rel="license" href="http://creativecommons.org/licenses/by/3.0/">Creative Commons By 3.0</a><br /><a rel="license" href="http://creativecommons.org/licenses/by/3.0/"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by/3.0/88x31.png" /></a>
                    </small>
                </p>
            </section>

        </div>
    </div>

    <script src="/third_party/reveal/lib/js/head.min.js"></script>
    <script src="/third_party/reveal/js/reveal.min.js"></script>

    <script>
        Reveal.initialize({
            controls: true,
            progress: true,
            history: true,
            center: true,

            theme: 'solarized', // available themes are in /css/theme
            transition: 'none', // default/cube/page/concave/zoom/linear/fade/none

            // Optional libraries used to extend on reveal.js
            dependencies: [
                { src: '/third_party/reveal/lib/js/classList.js', condition: function() { return !document.body.classList; } },
                //{ src: '/third_party/reveal/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                //{ src: '/third_party/reveal/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                { src: '/third_party/reveal/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                //{ src: '/third_party/reveal/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
                //{ src: '/third_party/reveal/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
            ]
        });

    </script>

</body>
</html>
